{"ast":null,"code":"import { h, withDirectives, ref, computed, watch, onMounted, onBeforeUnmount, nextTick, inject, getCurrentInstance } from 'vue';\nimport useHistory from '../../composables/private/use-history.js';\nimport useModelToggle, { useModelToggleProps, useModelToggleEmits } from '../../composables/private/use-model-toggle.js';\nimport usePreventScroll from '../../composables/private/use-prevent-scroll.js';\nimport useTimeout from '../../composables/private/use-timeout.js';\nimport useDark, { useDarkProps } from '../../composables/private/use-dark.js';\nimport TouchPan from '../../directives/TouchPan.js';\nimport { createComponent } from '../../utils/private/create.js';\nimport { between } from '../../utils/format.js';\nimport { hSlot, hDir } from '../../utils/private/render.js';\nimport { layoutKey } from '../../utils/private/symbols.js';\nconst duration = 150;\nexport default createComponent({\n  name: 'QDrawer',\n  inheritAttrs: false,\n  props: { ...useModelToggleProps,\n    ...useDarkProps,\n    side: {\n      type: String,\n      default: 'left',\n      validator: v => ['left', 'right'].includes(v)\n    },\n    width: {\n      type: Number,\n      default: 300\n    },\n    mini: Boolean,\n    miniToOverlay: Boolean,\n    miniWidth: {\n      type: Number,\n      default: 57\n    },\n    breakpoint: {\n      type: Number,\n      default: 1023\n    },\n    showIfAbove: Boolean,\n    behavior: {\n      type: String,\n      validator: v => ['default', 'desktop', 'mobile'].includes(v),\n      default: 'default'\n    },\n    bordered: Boolean,\n    elevated: Boolean,\n    overlay: Boolean,\n    persistent: Boolean,\n    noSwipeOpen: Boolean,\n    noSwipeClose: Boolean,\n    noSwipeBackdrop: Boolean\n  },\n  emits: [...useModelToggleEmits, 'on-layout', 'mini-state'],\n\n  setup(props, {\n    slots,\n    emit,\n    attrs\n  }) {\n    const vm = getCurrentInstance();\n    const {\n      proxy: {\n        $q\n      }\n    } = vm;\n    const isDark = useDark(props, $q);\n    const {\n      preventBodyScroll\n    } = usePreventScroll();\n    const {\n      registerTimeout\n    } = useTimeout();\n    const $layout = inject(layoutKey, () => {\n      console.error('QDrawer needs to be child of QLayout');\n    });\n    let lastDesktopState, timerMini, layoutTotalWidthWatcher;\n    const belowBreakpoint = ref(props.behavior === 'mobile' || props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint);\n    const isMini = computed(() => props.mini === true && belowBreakpoint.value !== true);\n    const size = computed(() => isMini.value === true ? props.miniWidth : props.width);\n    const showing = ref(props.showIfAbove === true && belowBreakpoint.value === false ? true : props.modelValue === true);\n    const hideOnRouteChange = computed(() => props.persistent !== true && (belowBreakpoint.value === true || onScreenOverlay.value === true));\n\n    function handleShow(evt, noEvent) {\n      addToHistory();\n      evt !== false && $layout.animate();\n      applyPosition(0);\n\n      if (belowBreakpoint.value === true) {\n        const otherInstance = $layout.instances[otherSide.value];\n\n        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {\n          otherInstance.hide(false);\n        }\n\n        applyBackdrop(1);\n        $layout.isContainer.value !== true && preventBodyScroll(true);\n      } else {\n        applyBackdrop(0);\n        evt !== false && setScrollable(false);\n      }\n\n      registerTimeout(() => {\n        evt !== false && setScrollable(true);\n        noEvent !== true && emit('show', evt);\n      }, duration);\n    }\n\n    function handleHide(evt, noEvent) {\n      removeFromHistory();\n      evt !== false && $layout.animate();\n      applyBackdrop(0);\n      applyPosition(stateDirection.value * size.value);\n      cleanup();\n      noEvent !== true && registerTimeout(() => {\n        emit('hide', evt);\n      }, duration);\n    }\n\n    const {\n      show,\n      hide\n    } = useModelToggle({\n      showing,\n      hideOnRouteChange,\n      handleShow,\n      handleHide\n    });\n    const {\n      addToHistory,\n      removeFromHistory\n    } = useHistory(showing, hide, hideOnRouteChange);\n    const instance = {\n      belowBreakpoint,\n      hide\n    };\n    const rightSide = computed(() => props.side === 'right');\n    const stateDirection = computed(() => ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1));\n    const flagBackdropBg = ref(0);\n    const flagPanning = ref(false);\n    const flagMiniAnimate = ref(false);\n    const flagContentPosition = ref( // starting with \"hidden\" for SSR\n    size.value * stateDirection.value);\n    const otherSide = computed(() => rightSide.value === true ? 'left' : 'right');\n    const offset = computed(() => showing.value === true && belowBreakpoint.value === false && props.overlay === false ? props.miniToOverlay === true ? props.miniWidth : size.value : 0);\n    const fixed = computed(() => props.overlay === true || props.miniToOverlay === true || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1 || $q.platform.is.ios === true && $layout.isContainer.value === true);\n    const onLayout = computed(() => props.overlay === false && showing.value === true && belowBreakpoint.value === false);\n    const onScreenOverlay = computed(() => props.overlay === true && showing.value === true && belowBreakpoint.value === false);\n    const backdropClass = computed(() => 'fullscreen q-drawer__backdrop' + (showing.value === false && flagPanning.value === false ? ' hidden' : ''));\n    const backdropStyle = computed(() => ({\n      backgroundColor: `rgba(0,0,0,${flagBackdropBg.value * 0.4})`\n    }));\n    const headerSlot = computed(() => rightSide.value === true ? $layout.rows.value.top[2] === 'r' : $layout.rows.value.top[0] === 'l');\n    const footerSlot = computed(() => rightSide.value === true ? $layout.rows.value.bottom[2] === 'r' : $layout.rows.value.bottom[0] === 'l');\n    const aboveStyle = computed(() => {\n      const css = {};\n\n      if ($layout.header.space === true && headerSlot.value === false) {\n        if (fixed.value === true) {\n          css.top = `${$layout.header.offset}px`;\n        } else if ($layout.header.space === true) {\n          css.top = `${$layout.header.size}px`;\n        }\n      }\n\n      if ($layout.footer.space === true && footerSlot.value === false) {\n        if (fixed.value === true) {\n          css.bottom = `${$layout.footer.offset}px`;\n        } else if ($layout.footer.space === true) {\n          css.bottom = `${$layout.footer.size}px`;\n        }\n      }\n\n      return css;\n    });\n    const style = computed(() => {\n      const style = {\n        width: `${size.value}px`,\n        transform: `translateX(${flagContentPosition.value}px)`\n      };\n      return belowBreakpoint.value === true ? style : Object.assign(style, aboveStyle.value);\n    });\n    const contentClass = computed(() => 'q-drawer__content fit ' + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto'));\n    const classes = computed(() => `q-drawer q-drawer--${props.side}` + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '') + (props.bordered === true ? ' q-drawer--bordered' : '') + (isDark.value === true ? ' q-drawer--dark q-dark' : '') + (flagPanning.value === true ? ' no-transition' : showing.value === true ? '' : ' q-layout--prevent-focus') + (belowBreakpoint.value === true ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding' : ` q-drawer--${isMini.value === true ? 'mini' : 'standard'}` + (fixed.value === true || onLayout.value !== true ? ' fixed' : '') + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '') + (headerSlot.value === true ? ' q-drawer--top-padding' : '')));\n    const openDirective = computed(() => {\n      // if props.noSwipeOpen !== true\n      const dir = $q.lang.rtl === true ? props.side : otherSide.value;\n      return [[TouchPan, onOpenPan, void 0, {\n        [dir]: true,\n        mouse: true\n      }]];\n    });\n    const contentCloseDirective = computed(() => {\n      // if belowBreakpoint.value === true && props.noSwipeClose !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side;\n      return [[TouchPan, onClosePan, void 0, {\n        [dir]: true,\n        mouse: true\n      }]];\n    });\n    const backdropCloseDirective = computed(() => {\n      // if showing.value === true && props.noSwipeBackdrop !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side;\n      return [[TouchPan, onClosePan, void 0, {\n        [dir]: true,\n        mouse: true,\n        mouseAllDir: true\n      }]];\n    });\n\n    function updateBelowBreakpoint() {\n      updateLocal(belowBreakpoint, props.behavior === 'mobile' || props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint);\n    }\n\n    watch(belowBreakpoint, val => {\n      if (val === true) {\n        // from lg to xs\n        lastDesktopState = showing.value;\n        showing.value === true && hide(false);\n      } else if (props.overlay === false && props.behavior !== 'mobile' && lastDesktopState !== false) {\n        // from xs to lg\n        if (showing.value === true) {\n          applyPosition(0);\n          applyBackdrop(0);\n          cleanup();\n        } else {\n          show(false);\n        }\n      }\n    });\n    watch(() => props.side, (newSide, oldSide) => {\n      if ($layout.instances[oldSide] === instance) {\n        $layout.instances[oldSide] = void 0;\n        $layout[oldSide].space = false;\n        $layout[oldSide].offset = 0;\n      }\n\n      $layout.instances[newSide] = instance;\n      $layout[newSide].size = size.value;\n      $layout[newSide].space = onLayout.value;\n      $layout[newSide].offset = offset.value;\n    });\n    watch($layout.totalWidth, () => {\n      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {\n        updateBelowBreakpoint();\n      }\n    });\n    watch(() => props.behavior + props.breakpoint, updateBelowBreakpoint);\n    watch($layout.isContainer, val => {\n      showing.value === true && preventBodyScroll(val !== true);\n      val === true && updateBelowBreakpoint();\n    });\n    watch($layout.scrollbarWidth, () => {\n      applyPosition(showing.value === true ? 0 : void 0);\n    });\n    watch(offset, val => {\n      updateLayout('offset', val);\n    });\n    watch(onLayout, val => {\n      emit('on-layout', val);\n      updateLayout('space', val);\n    });\n    watch(rightSide, () => {\n      applyPosition();\n    });\n    watch(size, val => {\n      applyPosition();\n      updateSizeOnLayout(props.miniToOverlay, val);\n    });\n    watch(() => props.miniToOverlay, val => {\n      updateSizeOnLayout(val, size.value);\n    });\n    watch(() => $q.lang.rtl, () => {\n      applyPosition();\n    });\n    watch(() => props.mini, () => {\n      if (props.modelValue === true) {\n        animateMini();\n        $layout.animate();\n      }\n    });\n    watch(isMini, val => {\n      emit('mini-state', val);\n    });\n\n    function applyPosition(position) {\n      if (position === void 0) {\n        nextTick(() => {\n          position = showing.value === true ? 0 : size.value;\n          applyPosition(stateDirection.value * position);\n        });\n      } else {\n        if ($layout.isContainer.value === true && rightSide.value === true && (belowBreakpoint.value === true || Math.abs(position) === size.value)) {\n          position += stateDirection.value * $layout.scrollbarWidth.value;\n        }\n\n        flagContentPosition.value = position;\n      }\n    }\n\n    function applyBackdrop(x) {\n      flagBackdropBg.value = x;\n    }\n\n    function setScrollable(v) {\n      const action = v === true ? 'remove' : $layout.isContainer.value !== true ? 'add' : '';\n      action !== '' && document.body.classList[action]('q-body--drawer-toggle');\n    }\n\n    function animateMini() {\n      clearTimeout(timerMini);\n\n      if (vm.proxy && vm.proxy.$el) {\n        // need to speed it up and apply it immediately,\n        // even faster than Vue's nextTick!\n        vm.proxy.$el.classList.add('q-drawer--mini-animate');\n      }\n\n      flagMiniAnimate.value = true;\n      timerMini = setTimeout(() => {\n        flagMiniAnimate.value = false;\n\n        if (vm && vm.proxy && vm.proxy.$el) {\n          vm.proxy.$el.classList.remove('q-drawer--mini-animate');\n        }\n      }, 150);\n    }\n\n    function onOpenPan(evt) {\n      if (showing.value !== false) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been opened (but animation is still pending)\n        return;\n      }\n\n      const width = size.value,\n            position = between(evt.distance.x, 0, width);\n\n      if (evt.isFinal === true) {\n        const opened = position >= Math.min(75, width);\n\n        if (opened === true) {\n          show();\n        } else {\n          $layout.animate();\n          applyBackdrop(0);\n          applyPosition(stateDirection.value * width);\n        }\n\n        flagPanning.value = false;\n        return;\n      }\n\n      applyPosition(($q.lang.rtl === true ? rightSide.value !== true : rightSide.value) ? Math.max(width - position, 0) : Math.min(0, position - width));\n      applyBackdrop(between(position / width, 0, 1));\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true;\n      }\n    }\n\n    function onClosePan(evt) {\n      if (showing.value !== true) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been closed (but animation is still pending)\n        return;\n      }\n\n      const width = size.value,\n            dir = evt.direction === props.side,\n            position = ($q.lang.rtl === true ? dir !== true : dir) ? between(evt.distance.x, 0, width) : 0;\n\n      if (evt.isFinal === true) {\n        const opened = Math.abs(position) < Math.min(75, width);\n\n        if (opened === true) {\n          $layout.animate();\n          applyBackdrop(1);\n          applyPosition(0);\n        } else {\n          hide();\n        }\n\n        flagPanning.value = false;\n        return;\n      }\n\n      applyPosition(stateDirection.value * position);\n      applyBackdrop(between(1 - position / width, 0, 1));\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true;\n      }\n    }\n\n    function cleanup() {\n      preventBodyScroll(false);\n      setScrollable(true);\n    }\n\n    function updateLayout(prop, val) {\n      $layout.update(props.side, prop, val);\n    }\n\n    function updateLocal(prop, val) {\n      if (prop.value !== val) {\n        prop.value = val;\n      }\n    }\n\n    function updateSizeOnLayout(miniToOverlay, size) {\n      updateLayout('size', miniToOverlay === true ? props.miniWidth : size);\n    }\n\n    $layout.instances[props.side] = instance;\n    updateSizeOnLayout(props.miniToOverlay, size.value);\n    updateLayout('space', onLayout.value);\n    updateLayout('offset', offset.value);\n\n    if (props.showIfAbove === true && props.modelValue !== true && showing.value === true && props['onUpdate:modelValue'] !== void 0) {\n      emit('update:modelValue', true);\n    }\n\n    onMounted(() => {\n      emit('on-layout', onLayout.value);\n      emit('mini-state', isMini.value);\n      lastDesktopState = props.showIfAbove === true;\n\n      const fn = () => {\n        const action = showing.value === true ? handleShow : handleHide;\n        action(false, true);\n      };\n\n      if ($layout.totalWidth.value !== 0) {\n        // make sure that all computed properties\n        // have been updated before calling handleShow/handleHide()\n        nextTick(fn);\n        return;\n      }\n\n      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {\n        layoutTotalWidthWatcher();\n        layoutTotalWidthWatcher = void 0;\n\n        if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {\n          show(false);\n        } else {\n          fn();\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher();\n      clearTimeout(timerMini);\n      showing.value === true && cleanup();\n\n      if ($layout.instances[props.side] === instance) {\n        $layout.instances[props.side] = void 0;\n        updateLayout('size', 0);\n        updateLayout('offset', 0);\n        updateLayout('space', false);\n      }\n    });\n    return () => {\n      const child = [];\n\n      if (belowBreakpoint.value === true) {\n        props.noSwipeOpen === false && child.push(withDirectives(h('div', {\n          key: 'open',\n          class: `q-drawer__opener fixed-${props.side}`,\n          'aria-hidden': 'true'\n        }), openDirective.value));\n        child.push(hDir('div', {\n          ref: 'backdrop',\n          class: backdropClass.value,\n          style: backdropStyle.value,\n          'aria-hidden': 'true',\n          onClick: hide\n        }, void 0, 'backdrop', props.noSwipeBackdrop !== true && showing.value === true, () => backdropCloseDirective.value));\n      }\n\n      const mini = isMini.value === true && slots.mini !== void 0;\n      const content = [h('div', { ...attrs,\n        key: '' + mini,\n        // required otherwise Vue will not diff correctly\n        class: [contentClass.value, attrs.class]\n      }, mini === true ? slots.mini() : hSlot(slots.default))];\n\n      if (props.elevated === true && showing.value === true) {\n        content.push(h('div', {\n          class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'\n        }));\n      }\n\n      child.push(hDir('aside', {\n        ref: 'content',\n        class: classes.value,\n        style: style.value\n      }, content, 'contentclose', props.noSwipeClose !== true && belowBreakpoint.value === true, () => contentCloseDirective.value));\n      return h('div', {\n        class: 'q-drawer-container'\n      }, child);\n    };\n  }\n\n});","map":{"version":3,"names":["h","withDirectives","ref","computed","watch","onMounted","onBeforeUnmount","nextTick","inject","getCurrentInstance","useHistory","useModelToggle","useModelToggleProps","useModelToggleEmits","usePreventScroll","useTimeout","useDark","useDarkProps","TouchPan","createComponent","between","hSlot","hDir","layoutKey","duration","name","inheritAttrs","props","side","type","String","default","validator","v","includes","width","Number","mini","Boolean","miniToOverlay","miniWidth","breakpoint","showIfAbove","behavior","bordered","elevated","overlay","persistent","noSwipeOpen","noSwipeClose","noSwipeBackdrop","emits","setup","slots","emit","attrs","vm","proxy","$q","isDark","preventBodyScroll","registerTimeout","$layout","console","error","lastDesktopState","timerMini","layoutTotalWidthWatcher","belowBreakpoint","totalWidth","value","isMini","size","showing","modelValue","hideOnRouteChange","onScreenOverlay","handleShow","evt","noEvent","addToHistory","animate","applyPosition","otherInstance","instances","otherSide","hide","applyBackdrop","isContainer","setScrollable","handleHide","removeFromHistory","stateDirection","cleanup","show","instance","rightSide","lang","rtl","flagBackdropBg","flagPanning","flagMiniAnimate","flagContentPosition","offset","fixed","view","indexOf","platform","is","ios","onLayout","backdropClass","backdropStyle","backgroundColor","headerSlot","rows","top","footerSlot","bottom","aboveStyle","css","header","space","footer","style","transform","Object","assign","contentClass","classes","openDirective","dir","onOpenPan","mouse","contentCloseDirective","onClosePan","backdropCloseDirective","mouseAllDir","updateBelowBreakpoint","updateLocal","val","newSide","oldSide","document","qScrollPrevented","scrollbarWidth","updateLayout","updateSizeOnLayout","animateMini","position","Math","abs","x","action","body","classList","clearTimeout","$el","add","setTimeout","remove","distance","isFinal","opened","min","max","isFirst","direction","prop","update","fn","child","push","key","class","onClick","content"],"sources":["/Users/hedermilani/Projetos/Projetos Vue/quasar/node_modules/quasar/src/components/drawer/QDrawer.js"],"sourcesContent":["import { h, withDirectives, ref, computed, watch, onMounted, onBeforeUnmount, nextTick, inject, getCurrentInstance } from 'vue'\n\nimport useHistory from '../../composables/private/use-history.js'\nimport useModelToggle, { useModelToggleProps, useModelToggleEmits } from '../../composables/private/use-model-toggle.js'\nimport usePreventScroll from '../../composables/private/use-prevent-scroll.js'\nimport useTimeout from '../../composables/private/use-timeout.js'\nimport useDark, { useDarkProps } from '../../composables/private/use-dark.js'\n\nimport TouchPan from '../../directives/TouchPan.js'\n\nimport { createComponent } from '../../utils/private/create.js'\nimport { between } from '../../utils/format.js'\nimport { hSlot, hDir } from '../../utils/private/render.js'\nimport { layoutKey } from '../../utils/private/symbols.js'\n\nconst duration = 150\n\nexport default createComponent({\n  name: 'QDrawer',\n\n  inheritAttrs: false,\n\n  props: {\n    ...useModelToggleProps,\n    ...useDarkProps,\n\n    side: {\n      type: String,\n      default: 'left',\n      validator: v => [ 'left', 'right' ].includes(v)\n    },\n\n    width: {\n      type: Number,\n      default: 300\n    },\n\n    mini: Boolean,\n    miniToOverlay: Boolean,\n    miniWidth: {\n      type: Number,\n      default: 57\n    },\n\n    breakpoint: {\n      type: Number,\n      default: 1023\n    },\n    showIfAbove: Boolean,\n\n    behavior: {\n      type: String,\n      validator: v => [ 'default', 'desktop', 'mobile' ].includes(v),\n      default: 'default'\n    },\n\n    bordered: Boolean,\n    elevated: Boolean,\n\n    overlay: Boolean,\n    persistent: Boolean,\n    noSwipeOpen: Boolean,\n    noSwipeClose: Boolean,\n    noSwipeBackdrop: Boolean\n  },\n\n  emits: [\n    ...useModelToggleEmits,\n    'on-layout', 'mini-state'\n  ],\n\n  setup (props, { slots, emit, attrs }) {\n    const vm = getCurrentInstance()\n    const { proxy: { $q } } = vm\n\n    const isDark = useDark(props, $q)\n    const { preventBodyScroll } = usePreventScroll()\n    const { registerTimeout } = useTimeout()\n\n    const $layout = inject(layoutKey, () => {\n      console.error('QDrawer needs to be child of QLayout')\n    })\n\n    let lastDesktopState, timerMini, layoutTotalWidthWatcher\n\n    const belowBreakpoint = ref(\n      props.behavior === 'mobile'\n      || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)\n    )\n\n    const isMini = computed(() =>\n      props.mini === true && belowBreakpoint.value !== true\n    )\n\n    const size = computed(() => (\n      isMini.value === true\n        ? props.miniWidth\n        : props.width\n    ))\n\n    const showing = ref(\n      props.showIfAbove === true && belowBreakpoint.value === false\n        ? true\n        : props.modelValue === true\n    )\n\n    const hideOnRouteChange = computed(() =>\n      props.persistent !== true\n      && (belowBreakpoint.value === true || onScreenOverlay.value === true)\n    )\n\n    function handleShow (evt, noEvent) {\n      addToHistory()\n\n      evt !== false && $layout.animate()\n      applyPosition(0)\n\n      if (belowBreakpoint.value === true) {\n        const otherInstance = $layout.instances[ otherSide.value ]\n        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {\n          otherInstance.hide(false)\n        }\n\n        applyBackdrop(1)\n        $layout.isContainer.value !== true && preventBodyScroll(true)\n      }\n      else {\n        applyBackdrop(0)\n        evt !== false && setScrollable(false)\n      }\n\n      registerTimeout(() => {\n        evt !== false && setScrollable(true)\n        noEvent !== true && emit('show', evt)\n      }, duration)\n    }\n\n    function handleHide (evt, noEvent) {\n      removeFromHistory()\n\n      evt !== false && $layout.animate()\n\n      applyBackdrop(0)\n      applyPosition(stateDirection.value * size.value)\n\n      cleanup()\n\n      noEvent !== true && registerTimeout(() => {\n        emit('hide', evt)\n      }, duration)\n    }\n\n    const { show, hide } = useModelToggle({\n      showing,\n      hideOnRouteChange,\n      handleShow,\n      handleHide\n    })\n\n    const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange)\n\n    const instance = {\n      belowBreakpoint,\n      hide\n    }\n\n    const rightSide = computed(() => props.side === 'right')\n\n    const stateDirection = computed(() =>\n      ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1)\n    )\n\n    const flagBackdropBg = ref(0)\n    const flagPanning = ref(false)\n    const flagMiniAnimate = ref(false)\n    const flagContentPosition = ref( // starting with \"hidden\" for SSR\n      size.value * stateDirection.value\n    )\n\n    const otherSide = computed(() => (rightSide.value === true ? 'left' : 'right'))\n    const offset = computed(() => (\n      showing.value === true && belowBreakpoint.value === false && props.overlay === false\n        ? (props.miniToOverlay === true ? props.miniWidth : size.value)\n        : 0\n    ))\n\n    const fixed = computed(() =>\n      props.overlay === true\n      || props.miniToOverlay === true\n      || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1\n      || ($q.platform.is.ios === true && $layout.isContainer.value === true)\n    )\n\n    const onLayout = computed(() =>\n      props.overlay === false\n      && showing.value === true\n      && belowBreakpoint.value === false\n    )\n\n    const onScreenOverlay = computed(() =>\n      props.overlay === true\n      && showing.value === true\n      && belowBreakpoint.value === false\n    )\n\n    const backdropClass = computed(() =>\n      'fullscreen q-drawer__backdrop'\n      + (showing.value === false && flagPanning.value === false ? ' hidden' : '')\n    )\n\n    const backdropStyle = computed(() => ({\n      backgroundColor: `rgba(0,0,0,${ flagBackdropBg.value * 0.4 })`\n    }))\n\n    const headerSlot = computed(() => (\n      rightSide.value === true\n        ? $layout.rows.value.top[ 2 ] === 'r'\n        : $layout.rows.value.top[ 0 ] === 'l'\n    ))\n\n    const footerSlot = computed(() => (\n      rightSide.value === true\n        ? $layout.rows.value.bottom[ 2 ] === 'r'\n        : $layout.rows.value.bottom[ 0 ] === 'l'\n    ))\n\n    const aboveStyle = computed(() => {\n      const css = {}\n\n      if ($layout.header.space === true && headerSlot.value === false) {\n        if (fixed.value === true) {\n          css.top = `${ $layout.header.offset }px`\n        }\n        else if ($layout.header.space === true) {\n          css.top = `${ $layout.header.size }px`\n        }\n      }\n\n      if ($layout.footer.space === true && footerSlot.value === false) {\n        if (fixed.value === true) {\n          css.bottom = `${ $layout.footer.offset }px`\n        }\n        else if ($layout.footer.space === true) {\n          css.bottom = `${ $layout.footer.size }px`\n        }\n      }\n\n      return css\n    })\n\n    const style = computed(() => {\n      const style = {\n        width: `${ size.value }px`,\n        transform: `translateX(${ flagContentPosition.value }px)`\n      }\n\n      return belowBreakpoint.value === true\n        ? style\n        : Object.assign(style, aboveStyle.value)\n    })\n\n    const contentClass = computed(() =>\n      'q-drawer__content fit '\n      + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto')\n    )\n\n    const classes = computed(() =>\n      `q-drawer q-drawer--${ props.side }`\n      + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '')\n      + (props.bordered === true ? ' q-drawer--bordered' : '')\n      + (isDark.value === true ? ' q-drawer--dark q-dark' : '')\n      + (\n        flagPanning.value === true\n          ? ' no-transition'\n          : (showing.value === true ? '' : ' q-layout--prevent-focus')\n      )\n      + (\n        belowBreakpoint.value === true\n          ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding'\n          : ` q-drawer--${ isMini.value === true ? 'mini' : 'standard' }`\n          + (fixed.value === true || onLayout.value !== true ? ' fixed' : '')\n          + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '')\n          + (headerSlot.value === true ? ' q-drawer--top-padding' : '')\n      )\n    )\n\n    const openDirective = computed(() => {\n      // if props.noSwipeOpen !== true\n      const dir = $q.lang.rtl === true ? props.side : otherSide.value\n\n      return [ [\n        TouchPan,\n        onOpenPan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true\n        }\n      ] ]\n    })\n\n    const contentCloseDirective = computed(() => {\n      // if belowBreakpoint.value === true && props.noSwipeClose !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side\n\n      return [ [\n        TouchPan,\n        onClosePan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true\n        }\n      ] ]\n    })\n\n    const backdropCloseDirective = computed(() => {\n      // if showing.value === true && props.noSwipeBackdrop !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side\n\n      return [ [\n        TouchPan,\n        onClosePan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true,\n          mouseAllDir: true\n        }\n      ] ]\n    })\n\n    function updateBelowBreakpoint () {\n      updateLocal(belowBreakpoint, (\n        props.behavior === 'mobile'\n        || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)\n      ))\n    }\n\n    watch(belowBreakpoint, val => {\n      if (val === true) { // from lg to xs\n        lastDesktopState = showing.value\n        showing.value === true && hide(false)\n      }\n      else if (\n        props.overlay === false\n        && props.behavior !== 'mobile'\n        && lastDesktopState !== false\n      ) { // from xs to lg\n        if (showing.value === true) {\n          applyPosition(0)\n          applyBackdrop(0)\n          cleanup()\n        }\n        else {\n          show(false)\n        }\n      }\n    })\n\n    watch(() => props.side, (newSide, oldSide) => {\n      if ($layout.instances[ oldSide ] === instance) {\n        $layout.instances[ oldSide ] = void 0\n        $layout[ oldSide ].space = false\n        $layout[ oldSide ].offset = 0\n      }\n\n      $layout.instances[ newSide ] = instance\n      $layout[ newSide ].size = size.value\n      $layout[ newSide ].space = onLayout.value\n      $layout[ newSide ].offset = offset.value\n    })\n\n    watch($layout.totalWidth, () => {\n      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {\n        updateBelowBreakpoint()\n      }\n    })\n\n    watch(\n      () => props.behavior + props.breakpoint,\n      updateBelowBreakpoint\n    )\n\n    watch($layout.isContainer, val => {\n      showing.value === true && preventBodyScroll(val !== true)\n      val === true && updateBelowBreakpoint()\n    })\n\n    watch($layout.scrollbarWidth, () => {\n      applyPosition(showing.value === true ? 0 : void 0)\n    })\n\n    watch(offset, val => { updateLayout('offset', val) })\n\n    watch(onLayout, val => {\n      emit('on-layout', val)\n      updateLayout('space', val)\n    })\n\n    watch(rightSide, () => { applyPosition() })\n\n    watch(size, val => {\n      applyPosition()\n      updateSizeOnLayout(props.miniToOverlay, val)\n    })\n\n    watch(() => props.miniToOverlay, val => {\n      updateSizeOnLayout(val, size.value)\n    })\n\n    watch(() => $q.lang.rtl, () => { applyPosition() })\n\n    watch(() => props.mini, () => {\n      if (props.modelValue === true) {\n        animateMini()\n        $layout.animate()\n      }\n    })\n\n    watch(isMini, val => { emit('mini-state', val) })\n\n    function applyPosition (position) {\n      if (position === void 0) {\n        nextTick(() => {\n          position = showing.value === true ? 0 : size.value\n          applyPosition(stateDirection.value * position)\n        })\n      }\n      else {\n        if (\n          $layout.isContainer.value === true\n          && rightSide.value === true\n          && (belowBreakpoint.value === true || Math.abs(position) === size.value)\n        ) {\n          position += stateDirection.value * $layout.scrollbarWidth.value\n        }\n\n        flagContentPosition.value = position\n      }\n    }\n\n    function applyBackdrop (x) {\n      flagBackdropBg.value = x\n    }\n\n    function setScrollable (v) {\n      const action = v === true\n        ? 'remove'\n        : ($layout.isContainer.value !== true ? 'add' : '')\n\n      action !== '' && document.body.classList[ action ]('q-body--drawer-toggle')\n    }\n\n    function animateMini () {\n      clearTimeout(timerMini)\n\n      if (vm.proxy && vm.proxy.$el) {\n        // need to speed it up and apply it immediately,\n        // even faster than Vue's nextTick!\n        vm.proxy.$el.classList.add('q-drawer--mini-animate')\n      }\n\n      flagMiniAnimate.value = true\n      timerMini = setTimeout(() => {\n        flagMiniAnimate.value = false\n        if (vm && vm.proxy && vm.proxy.$el) {\n          vm.proxy.$el.classList.remove('q-drawer--mini-animate')\n        }\n      }, 150)\n    }\n\n    function onOpenPan (evt) {\n      if (showing.value !== false) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been opened (but animation is still pending)\n        return\n      }\n\n      const\n        width = size.value,\n        position = between(evt.distance.x, 0, width)\n\n      if (evt.isFinal === true) {\n        const opened = position >= Math.min(75, width)\n\n        if (opened === true) {\n          show()\n        }\n        else {\n          $layout.animate()\n          applyBackdrop(0)\n          applyPosition(stateDirection.value * width)\n        }\n\n        flagPanning.value = false\n        return\n      }\n\n      applyPosition(\n        ($q.lang.rtl === true ? rightSide.value !== true : rightSide.value)\n          ? Math.max(width - position, 0)\n          : Math.min(0, position - width)\n      )\n      applyBackdrop(\n        between(position / width, 0, 1)\n      )\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true\n      }\n    }\n\n    function onClosePan (evt) {\n      if (showing.value !== true) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been closed (but animation is still pending)\n        return\n      }\n\n      const\n        width = size.value,\n        dir = evt.direction === props.side,\n        position = ($q.lang.rtl === true ? dir !== true : dir)\n          ? between(evt.distance.x, 0, width)\n          : 0\n\n      if (evt.isFinal === true) {\n        const opened = Math.abs(position) < Math.min(75, width)\n\n        if (opened === true) {\n          $layout.animate()\n          applyBackdrop(1)\n          applyPosition(0)\n        }\n        else {\n          hide()\n        }\n\n        flagPanning.value = false\n        return\n      }\n\n      applyPosition(stateDirection.value * position)\n      applyBackdrop(between(1 - position / width, 0, 1))\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true\n      }\n    }\n\n    function cleanup () {\n      preventBodyScroll(false)\n      setScrollable(true)\n    }\n\n    function updateLayout (prop, val) {\n      $layout.update(props.side, prop, val)\n    }\n\n    function updateLocal (prop, val) {\n      if (prop.value !== val) {\n        prop.value = val\n      }\n    }\n\n    function updateSizeOnLayout (miniToOverlay, size) {\n      updateLayout('size', miniToOverlay === true ? props.miniWidth : size)\n    }\n\n    $layout.instances[ props.side ] = instance\n    updateSizeOnLayout(props.miniToOverlay, size.value)\n    updateLayout('space', onLayout.value)\n    updateLayout('offset', offset.value)\n\n    if (\n      props.showIfAbove === true\n      && props.modelValue !== true\n      && showing.value === true\n      && props[ 'onUpdate:modelValue' ] !== void 0\n    ) {\n      emit('update:modelValue', true)\n    }\n\n    onMounted(() => {\n      emit('on-layout', onLayout.value)\n      emit('mini-state', isMini.value)\n\n      lastDesktopState = props.showIfAbove === true\n\n      const fn = () => {\n        const action = showing.value === true ? handleShow : handleHide\n        action(false, true)\n      }\n\n      if ($layout.totalWidth.value !== 0) {\n        // make sure that all computed properties\n        // have been updated before calling handleShow/handleHide()\n        nextTick(fn)\n        return\n      }\n\n      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {\n        layoutTotalWidthWatcher()\n        layoutTotalWidthWatcher = void 0\n\n        if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {\n          show(false)\n        }\n        else {\n          fn()\n        }\n      })\n    })\n\n    onBeforeUnmount(() => {\n      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher()\n      clearTimeout(timerMini)\n\n      showing.value === true && cleanup()\n\n      if ($layout.instances[ props.side ] === instance) {\n        $layout.instances[ props.side ] = void 0\n        updateLayout('size', 0)\n        updateLayout('offset', 0)\n        updateLayout('space', false)\n      }\n    })\n\n    return () => {\n      const child = []\n\n      if (belowBreakpoint.value === true) {\n        props.noSwipeOpen === false && child.push(\n          withDirectives(\n            h('div', {\n              key: 'open',\n              class: `q-drawer__opener fixed-${ props.side }`,\n              'aria-hidden': 'true'\n            }),\n            openDirective.value\n          )\n        )\n\n        child.push(\n          hDir(\n            'div',\n            {\n              ref: 'backdrop',\n              class: backdropClass.value,\n              style: backdropStyle.value,\n              'aria-hidden': 'true',\n              onClick: hide\n            },\n            void 0,\n            'backdrop',\n            props.noSwipeBackdrop !== true && showing.value === true,\n            () => backdropCloseDirective.value\n          )\n        )\n      }\n\n      const mini = isMini.value === true && slots.mini !== void 0\n      const content = [\n        h('div', {\n          ...attrs,\n          key: '' + mini, // required otherwise Vue will not diff correctly\n          class: [\n            contentClass.value,\n            attrs.class\n          ]\n        }, mini === true\n          ? slots.mini()\n          : hSlot(slots.default)\n        )\n      ]\n\n      if (props.elevated === true && showing.value === true) {\n        content.push(\n          h('div', {\n            class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'\n          })\n        )\n      }\n\n      child.push(\n        hDir(\n          'aside',\n          { ref: 'content', class: classes.value, style: style.value },\n          content,\n          'contentclose',\n          props.noSwipeClose !== true && belowBreakpoint.value === true,\n          () => contentCloseDirective.value\n        )\n      )\n\n      return h('div', { class: 'q-drawer-container' }, child)\n    }\n  }\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}